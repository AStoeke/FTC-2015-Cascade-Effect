#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  HTMotor)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     Touch,          sensorTouch)
#pragma config(Motor,  mtr_S1_C1_1,     LeftFront,     tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     LeftRear,      tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     RightFront,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     RightRear,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     FrontArm,      tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C4_2,     BackArm,       tmotorTetrix, openLoop, encoder)
#pragma config(Servo,  srvo_S1_C3_1,    Flipper,              tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    ShoopShoop,           tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"
int spddiv;    //Speed Division Variable
//int firstVar = nMotorEncoder[FrontArm];
//int secondVar = nMotorEncoder[BackArm];
task main()
{
    nMotorEncoder[FrontArm] = 0;
    nMotorEncoder[BackArm] = 0;
    int threshold = 25;    //deadzone minimum for joystick
    disableDiagnosticsDisplay();
    servo[Flipper] = 155;
     wait1Msec(500);
 // waitForStart();

  while(true)
  {
    getJoystickSettings(joystick);    //get current joystick values
    spddiv = 4;     //set default speed division

        if(joy1Btn(8))
        {
            spddiv = 8;     //slow mo button- divide speed by 8
        }
        //left wheels
    if(abs(joystick.joy1_y1) > threshold)
    {
      motor[LeftFront] = joystick.joy1_y1/spddiv;
      motor[LeftRear] = joystick.joy1_y1/spddiv;
    }
    else
    {
      motor[LeftFront] = 0;
      motor[LeftRear] = 0;
    }
//right wheels
    if(abs(joystick.joy1_y2) > threshold)
    {
      motor[RightFront] = joystick.joy1_y2/spddiv;
      motor[RightRear] = joystick.joy1_y2/spddiv;
    }
    else
    {
      motor[RightFront] = 0;
      motor[RightRear] = 0;
    }
//move flipper to down position
    if(joy1Btn(3))
        {
            servo[Flipper] = 235;
           wait1Msec(500);
        }
//move flipper up
        if(joy1Btn(4))
        {
           servo[Flipper] = 155;
          wait1Msec(500);
        }

        if(joy2Btn(4))
        {
            motor[FrontArm] = 100;
            motor[BackArm] = 100;
        }
        else if(joy2Btn(3)) {
            if(SensorValue[Touch] == 0) {
            motor[FrontArm] = -100;
            motor[BackArm] = -100;
        }
        else if(SensorValue[Touch] == 1) {
            nMotorEncoder[FrontArm] = 0;
            nMotorEncoder[BackArm] = 0;
            motor[FrontArm] = 0;
            motor[BackArm] = 0;
    }    }
        else
        {
            motor[FrontArm] = 0;
            motor[BackArm] = 0;
        }

        if(joy2Btn(1))
        {
            servo[ShoopShoop] = 0;
        }
/*        else
        {
            servo[ShoopShoop] = 127;
        }*/
        else if(joy2Btn(2))
        {
            servo[ShoopShoop] = 255;
        }
        else
        {
            servo[ShoopShoop] = 127;
        }

//Arm Encoder Thingy

         if(joy2Btn(6))
         {
            while(nMotorEncoder[FrontArm] < 6800)
            {
                motor[FrontArm] = 100;
                motor[BackArm] = 100;
            }
        }

        if(joy2Btn(8))
        {
            while(nMotorEncoder[FrontArm] > 100)
            {
                motor[FrontArm] = -100;
                motor[BackArm] = -100;
            }
        }
    }
}


